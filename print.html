<!DOCTYPE HTML>
<html lang="zh" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>dialogue macro</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom/translate.css">


    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">2.</strong> QuickStart</a></li><li class="chapter-item expanded "><a href="guide/index.html"><strong aria-hidden="true">3.</strong> Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guide/input.html"><strong aria-hidden="true">3.1.</strong> Input</a></li><li class="chapter-item expanded "><a href="guide/password.html"><strong aria-hidden="true">3.2.</strong> Password</a></li><li class="chapter-item expanded "><a href="guide/confirm.html"><strong aria-hidden="true">3.3.</strong> Confirm</a></li><li class="chapter-item expanded "><a href="guide/select.html"><strong aria-hidden="true">3.4.</strong> Select</a></li><li class="chapter-item expanded "><a href="guide/multiselect.html"><strong aria-hidden="true">3.5.</strong> Multiselect</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/index.html"><strong aria-hidden="true">4.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/enum.html"><strong aria-hidden="true">4.1.</strong> EnumAsker</a></li><li class="chapter-item expanded "><a href="advanced/subasker.html"><strong aria-hidden="true">4.2.</strong> SubAsker</a></li><li class="chapter-item expanded "><a href="advanced/theme.html"><strong aria-hidden="true">4.3.</strong> Theme</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title ignore">dialogue macro</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/yexiyue/dialogue-macro" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        <span id="translate"></span>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/yexiyue/dialogue-macro"><img src="https://img.shields.io/github/stars/yexiyue/dialogue-macro?style=flat-square" alt="GitHub Stars" /></a> <a href="https://crates.io/crates/dialogue-macro"><img src="https://img.shields.io/crates/v/dialogue-macro?style=flat-square" alt="Crates.io" /></a></p>
<p><code>dialogue-macro</code> 是一款使用 Rust 语言设计的宏库，致力于无缝对接并增强 <code>dialoguer</code> 库的功能表现，采用声明式的编程模式简化命令行提示界面的构建流程。该库在实现结构化、层次化的用户交互体验上表现出色，尤其适应于命令行应用程序中各类复杂信息收集和配置选项设定的需求。</p>
<p><strong>核心特性概览：</strong></p>
<ol>
<li>
<p><strong>结构体与枚举支持</strong>：
dialogue-macro 允许开发者通过派生宏 (<code>#[derive(Asker)]</code> 和 <code>#[derive(EnumAsker)]</code>) 将自定义结构体及枚举类型转换为功能完备的命令行询问器，从而依据预定义的字段或枚举成员进行高效的数据采集。</p>
</li>
<li>
<p><strong>嵌套式交互逻辑</strong>：
提供了对嵌套子询问器的支持，通过在结构体成员上标注 <code>#[asker(SubAsker)]</code> 属性，可实现多层次、递进式的用户交互过程，以应对不同场景下的深度信息获取需求。</p>
</li>
<li>
<p><strong>主题定制能力</strong>：
支持主题设置，如示例中的 <code>dialogue_macro::ColorfulTheme</code>，使得开发者能够根据实际需要选择和应用不同的视觉风格，提升命令行提示界面的用户体验和可读性。</p>
</li>
</ol>
<p>文档中所展示的示例代码片段，可以在<a href="https://github.com/yexiyue/dialogue-macro">GitHub仓库</a>的examples目录下找到并获取。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<p>首先通过cargo添加<code>dialogue-macro</code>依赖:</p>
<pre><code class="language-bash">cargo add dialogue-macro
</code></pre>
<p>然后在您的Rust代码中导入该crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dialogue_macro::Asker;
<span class="boring">}</span></code></pre></pre>
<p>接下来,使用<code>#[derive(Asker, Debug)]</code>宏来为需要交互式输入的结构体派生相关trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Asker, Debug)]
struct User {
    #[input(prompt = "请输入您的名字:")]
    name: String,
    age: u32,
}
<span class="boring">}</span></code></pre></pre>
<p><code>#[derive(Asker)]</code>会自动为结构体实现<code>asker()</code>构造器方法。对于带有<code>#[input(prompt = "...")]</code>属性的字段,您可以直接调用同名方法(无需再传入提示文本作为参数)。</p>
<p>最后,使用派生的方法链式调用来获取用户输入:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let user = User::asker()
        .name()
        .age("请输入您的年龄:")
        .finish();

    println!("{:?}", user);
}</code></pre></pre>
<p>运行该程序,您将看到类似以下的交互式提示:</p>
<p><img src="quickstart.assets/image-20240316103136567.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide"><a class="header" href="#guide">Guide</a></h1>
<p>在接下来的章节中,我们将详细介绍<code>Asker</code>提供的5种常用命令行交互方式:</p>
<ul>
<li><strong>Input</strong> - 用于获取常规文本输入。</li>
<li><strong>Password</strong> - 适用于需要保密信息（如密码）的安全输入场景。</li>
<li><strong>Confirm</strong> - 获取用户对某一问题的确认或否定响应。</li>
<li><strong>Select</strong> - 提供选项列表供用户选择单个项。</li>
<li><strong>Multiselect</strong> - 允许用户从选项列表中选择多个项目。</li>
</ul>
<p>每种交互方式都支持以下几个通用参数:</p>
<ul>
<li><code>prompt</code>: 交互提示信息</li>
<li><code>default</code>: 默认值</li>
<li><code>with_default</code>: 是否在同名方法中传入default参数，默认为<code>false</code></li>
</ul>
<p>如果在结构体字段上指定了<code>prompt</code>,那么在调用同名方法时就无需再传入<code>prompt</code>参数。</p>
<p>如果字段声明了<code>default</code>属性,那么在交互提示时会显示该默认输入值。</p>
<p><strong>注意：</strong></p>
<p><code>with_default</code>的优先级高于<code>default</code>,意味着如果两者冲突,将使用同名方法的参数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input"><a class="header" href="#input">Input</a></h1>
<p><code>Input</code>用于接收用户的文本或数字输入。</p>
<h4 id="定义input字段"><a class="header" href="#定义input字段">定义Input字段</a></h4>
<p>使用<code>dialogue_macro::Asker</code>宏为结构体派生trait时，框架会自动将以下字段类型识别为<code>Input</code>输入字段:</p>
<ul>
<li><code>String</code></li>
<li>基本数字类型，如<code>i32</code>、<code>u32</code>、<code>usize</code>等</li>
</ul>
<p>如果某个字段为非必填项，可将其声明为<code>Option&lt;String&gt;</code>或对应的<code>Option&lt;数字类型&gt;</code>。这样在调用<code>finish()</code>方法时，如果没有调用该同名方法，程序不会panic。</p>
<h4 id="配置选项"><a class="header" href="#配置选项">配置选项</a></h4>
<ul>
<li><strong>prompt</strong>: 指定提示用户输入信息的文本内容。</li>
<li><strong>default</strong>: 设置字段的默认值，在询问用户时显示该默认值供参考或直接采用。</li>
<li><strong>with_default</strong>: 布尔值参数，当设为<code>true</code>时，在调用相应方法时需要传递默认值。</li>
</ul>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<p>在以下的 Rust 代码示例中，我们利用 <code>dialogue_macro</code> 库来实现一个用户交互式信息收集的场景。定义了一个结构体 <code>User</code>，它包含四个字段：<code>name</code>、<code>email</code>、<code>age</code> 和 <code>school</code>，分别用于收集用户的姓名、电子邮件地址、年龄和学校信息。</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
use dialogue_macro::Asker;

#[derive(Asker, Debug)]
struct User {
    name: Option&lt;String&gt;,
    #[input(prompt = "请输入您的邮箱地址: ", with_default = true)]
    email: String,
    #[input(with_default = true)]
    age: u8,
    #[input(prompt = "请输入您的学校名称: ", default = "清华大学")]
    school: Option&lt;String&gt;,
}

fn main() {

    let user = User::asker()
        .name("请输入您的姓名: ")
        .email("yexiyue666@qq.com".to_string())
        .age("请输入您的年龄", 17)
        .school()
        .finish();

    println!("{:?}", user);
}</code></pre></pre>
<p><img src="guide/input.assets/image-20240316141307176.png" alt="image-20240316141307176" /></p>
<p>在上述示例中：</p>
<ul>
<li><code>name</code> 字段是一个可选字符串类型，用户可以选择是否输入姓名。</li>
<li><code>email</code> 字段要求用户输入电子邮件地址，并支持传入默认值，通过 <code>.email()</code> 方法传递。</li>
<li><code>age</code> 字段用于获取用户年龄，也支持默认值，此处默认值为17岁。</li>
<li><code>school</code> 字段允许用户输入学校名称，同时提供了默认值"清华大学"。</li>
</ul>
<p>在 <code>main</code> 函数中：</p>
<ul>
<li>我们初始化了 <code>User</code> 结构体的询问器实例，并为每个字段指定了相应的提示信息和/或默认值。</li>
<li>当运行程序时，将按照定义顺序逐个展示各个字段的提示信息，并依据是否设置了默认值进行交互式信息收集。</li>
<li>收集完成后，<code>user.finish()</code> 返回一个包含了用户输入信息的 <code>User</code> 结构体实例，并将其输出至控制台。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="password"><a class="header" href="#password">Password</a></h1>
<p><code>Password</code>用于获取用户的密码输入,它会在终端中隐藏用户输入的字符。</p>
<h4 id="定义password字段"><a class="header" href="#定义password字段">定义Password字段</a></h4>
<p>要将字段定义为<code>Password</code>类型,需要使用<code>#[password(...)]</code>属性对字段进行标注,字段类型必须为<code>String</code>或<code>Option&lt;String&gt;</code>。与<code>Input</code>类似,如果字段为非必填项,可以声明为<code>Option&lt;String&gt;</code>。</p>
<p><code>Password</code>不支持<code>default</code>和<code>with_default</code>参数。</p>
<h4 id="配置选项-1"><a class="header" href="#配置选项-1">配置选项</a></h4>
<ul>
<li><strong>prompt</strong>: 指定提示用户输入密码的文本内容。</li>
<li><strong>confirmation</strong>: 指定提示用户再次确认密码的文本内容。</li>
<li><strong>mismatch</strong>: 当用户两次输入的密码不匹配时显示的错误信息。</li>
</ul>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
use dialogue_macro::Asker;

#[derive(Asker, Debug)]
struct User {
    // 普通密码输入字段，用户可选择是否输入密码
    #[password()]
    password: Option&lt;String&gt;,

    // 带确认和错误提示的密码输入字段
    #[password(
        prompt = "输入密码:",
        confirmation = "再次输入密码:",
        mismatch = "两次输入的密码不匹配"
    )]
    password2: String,
}

fn main() {

    let user = User::asker()
        .password2()
        .password("输入密码:")
        .finish();

    println!("{:?}", user);
}</code></pre></pre>
<p><img src="guide/password.assets/image-20240316142937549.png" alt="image-20240316142937549" /></p>
<p><img src="guide/password.assets/image-20240316143000299.png" alt="image-20240316143000299" /></p>
<p>在这个例子中：</p>
<ul>
<li><code>password2</code> 字段要求用户提供一个密码，并需要再次确认输入以确保正确无误。如果两次输入的密码不匹配，则会显示预设的错误信息“两次输入的密码不匹配”。</li>
</ul>
<p>在 <code>main</code> 函数中：</p>
<ul>
<li>我们首先初始化了 <code>User</code> 结构体的询问器实例，并按照逻辑顺序依次收集用户的密码输入信息。</li>
<li>当运行程序时，会根据定义的提示信息提示用户输入密码，并检查密码确认过程中的匹配性。</li>
<li>收集完成后，<code>.finish()</code> 方法返回一个包含了用户输入密码信息的 <code>User</code> 结构体实例，并将其输出至控制台。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="confirm"><a class="header" href="#confirm">Confirm</a></h1>
<p><code>Confirm</code> 用于获取用户的布尔值确认输入(是或否)。</p>
<h4 id="定义-confirm-字段"><a class="header" href="#定义-confirm-字段"><strong>定义 Confirm 字段</strong></a></h4>
<p>要将字段定义为 <code>Confirm</code> 类型,只需将其声明为 <code>bool</code> 或 <code>Option&lt;bool&gt;</code> 类型。与 <code>Input</code> 类似,如果字段为非必填项,可以声明为 <code>Option&lt;bool&gt;</code>。</p>
<h4 id="配置选项-2"><a class="header" href="#配置选项-2"><strong>配置选项</strong></a></h4>
<ul>
<li><strong>prompt</strong>: 指定提示用户进行确认的文本内容。</li>
<li><strong>default</strong>: 设置字段的默认值(<code>true</code> 或 <code>false</code>),在询问用户时显示该默认值供参考或直接采用。</li>
<li><strong>with_default</strong>: 布尔值参数,当设为 <code>true</code> 时,在调用相应方法时需要传递默认值。</li>
</ul>
<h4 id="示例-2"><a class="header" href="#示例-2"><strong>示例</strong></a></h4>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
use dialogue_macro::Asker;

#[derive(Asker, Debug)]
struct User {
    boy: bool,

    #[confirm(prompt = "Are you a student?", with_default = true)]
    student: Option&lt;bool&gt;,
}

fn main() {

    let user = User::asker()
        .boy("Are you a boy?")
        .student(true)
        .finish();

    println!("{:?}", user);
}
</code></pre></pre>
<p><img src="guide/confirm.assets/image-20240316141820068.png" alt="image-20240316141820068" /></p>
<p>在上述代码中：</p>
<ul>
<li><code>User</code> 结构体中的 <code>boy</code> 字段是一个布尔类型变量，通过询问用户来确定其性别。</li>
<li><code>student</code> 字段是一个具有默认值的可选布尔类型变量，通过 <code>#[confirm]</code> 宏提供了自定义确认提示 "Are you a student?"，默认情况下用户被假设为学生（值为 <code>true</code>）。</li>
</ul>
<p>在 <code>main</code> 函数中：</p>
<ul>
<li>我们初始化了 <code>User</code> 结构体的询问器实例，并分别为 <code>boy</code> 和 <code>student</code> 字段指定了提示信息和默认值。</li>
<li>当运行程序时，会依次显示预设的提示信息，并根据默认值进行交互式信息收集。</li>
<li>收集过程完成后，<code>.finish()</code> 方法返回一个包含了用户回答信息的 <code>User</code> 结构体实例，并将其输出至控制台。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">Select</a></h1>
<p><code>Select</code> 用于从给定选项列表中让用户选择一项。</p>
<h4 id="定义-select-字段"><a class="header" href="#定义-select-字段">定义 Select 字段</a></h4>
<p>要将字段定义为 <code>Select</code> 类型,需要使用 <code>#[select(...)]</code> 属性对字段进行标注。字段类型必须为 <code>String</code> 或实现了 <code>ToString</code> trait 的类型(<code>T</code>)或 <code>Option&lt;T&gt;</code>。</p>
<p>如果没有提供 <code>options</code> 配置选项,则需要在调用相应方法时传递选项列表。</p>
<p><strong>注意：<code>T</code>类型也必须实现<code>Clone</code>trait</strong></p>
<h4 id="配置选项-3"><a class="header" href="#配置选项-3">配置选项</a></h4>
<ul>
<li><strong>prompt</strong>: 指定提示用户进行选择的文本内容。</li>
<li><strong>options</strong>: 包含选项列表的数组或向量,每个选项必须实现 <code>ToString</code> trait。</li>
<li><strong>default</strong>: 设置默认选中项的索引(从 0 开始)。</li>
<li><strong>with_default</strong>: 布尔值参数,当设为 <code>true</code> 时,在调用相应方法时需要传递默认值的索引。</li>
</ul>
<h4 id="示例-3"><a class="header" href="#示例-3">示例</a></h4>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
use dialogue_macro::Asker;

#[derive(Asker, Debug)]
struct User {
    
    #[select(prompt = "Please select your sex", options = ["Male", "Female", "Other"], default = 1)]
    sex: String,

    #[select(
        prompt = "Please select your school: ",
        default = 1,
        options = [
            School { name: "Tsinghua University".to_string() },
            School { name: "Peking University".to_string() },
            School { name: "Henan Polytechnic University".to_string() }
        ],
        with_default = true
    )]
    school: Option&lt;School&gt;,


    #[select()]
    favorite: String,
}

// 定义表示学校的结构体，实现Debug和Clone特质
#[derive(Debug, Clone)]
struct School {
    name: String,
}

// 实现ToString trait，将School结构体转换为字符串形式
impl ToString for School {
    fn to_string(&amp;self) -&gt; String {
        self.name.clone()
    }
}

fn main() {

    let options = vec!["Eat".to_string(), "Sleep".to_string(), "Coding".to_string()];

    let user = User::asker()
        .sex()
        .school(2)
        .favorite("Please select your favorite:", &amp;options)
        .finish();

    println!("{:?}", user);
}
</code></pre></pre>
<p><img src="guide/select.assets/image-20240316142544158.png" alt="image-20240316142544158" /></p>
<p>在此示例中：</p>
<ul>
<li><code>sex</code> 字段是一个多选类型，提供了预设的性别选项，默认选择“Female”。</li>
<li><code>school</code> 字段也是一个多选类型，使用了自定义的 <code>School</code> 结构体来描述学校选项，并指定了默认值的索引为2（对应于“Henan Polytechnic University”）。</li>
<li><code>favorite</code> 字段同样为多选类型，但在调用 <code>.favorite()</code> 方法时需要传入选项列表和提示信息。</li>
</ul>
<p>在 <code>main</code> 函数中：</p>
<ul>
<li>我们首先定义了一个表示用户最喜欢的活动选项列表。</li>
<li>然后初始化了 <code>User</code> 结构体的询问器实例，并分别为 <code>sex</code>、<code>school</code> 和 <code>favorite</code> 字段指定了默认值或选项列表。</li>
<li>当运行程序时，会按照顺序展示预设的提示信息，并根据提供的默认值和选项进行交互式信息收集。</li>
<li>收集完成后，<code>.finish()</code> 方法返回一个包含了用户回答信息的 <code>User</code> 结构体实例，并将其输出至控制台。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiselect"><a class="header" href="#multiselect">Multiselect</a></h1>
<p><code>Multiselect</code> 用于从给定选项列表中让用户选择多项。</p>
<h4 id="定义-multiselect-字段"><a class="header" href="#定义-multiselect-字段">定义 Multiselect 字段</a></h4>
<p>要将字段定义为 <code>Multiselect</code> 类型,需要使用 <code>#[multiselect(...)]</code> 属性对字段进行标注,字段类型必须为 <code>Vec&lt;T&gt;</code>(其中 <code>T</code> 实现了 <code>ToString</code> trait)。</p>
<p><strong>注意:</strong></p>
<ul>
<li><strong><code>Multiselect</code> 不支持 <code>Option&lt;Vec&lt;T&gt;&gt;</code> 类型。</strong></li>
<li><strong><code>T</code>类型也必须实现<code>Clone</code>trait</strong></li>
</ul>
<h4 id="配置选项-4"><a class="header" href="#配置选项-4">配置选项</a></h4>
<ul>
<li><strong>prompt</strong>: 指定提示用户进行多选的文本内容。</li>
<li><strong>options</strong>: 包含选项列表的数组或向量,每个选项必须实现 <code>ToString</code> trait。</li>
<li><strong>default</strong>: 设置默认选中项的索引列表(从 0 开始)。</li>
<li><strong>with_default</strong>: 布尔值参数,当设为 <code>true</code> 时,在调用相应方法时需要传递一个布尔值数组,其中 <code>true</code> 表示选中对应索引的选项。传入的布尔值数组长度必须与选项列表长度相同。</li>
</ul>
<h4 id="示例-4"><a class="header" href="#示例-4">示例</a></h4>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
use dialogue_macro::Asker;

#[derive(Asker, Debug)]
struct User {
    #[multiselect(prompt = "Please select your favorite", options = ["Eat", "Sleep", "Code"], default = [1])]
    favorite: Vec&lt;String&gt;,

    #[multiselect(
        prompt = "Please select your school: ",
        with_default = true,
        options = [
            School { name: "Tsinghua University".to_string() },
            School { name: "Peking University".to_string() },
            School { name: "Henan Polytechnic University".to_string() }
        ]
    )]
    school: Vec&lt;School&gt;,
}

// 定义表示学校的结构体，并实现Debug和Clone特质
#[derive(Debug, Clone)]
struct School {
    name: String,
}

// 实现ToString trait，将School结构体转换为字符串形式以便于展示
impl ToString for School {
    fn to_string(&amp;self) -&gt; String {
        self.name.clone()
    }
}

fn main() {

    let user = User::asker()
        .school(&amp;[true, false, true])
        .favorite()
        .finish();


    println!("{:?}", user);
}</code></pre></pre>
<img src="guide/multiselect.assets/image-20240316144222151.png" alt="image-20240316144222151"  />
<p><img src="guide/multiselect.assets/image-20240316144238610.png" alt="image-20240316144238610" /></p>
<p>在这个示例中：</p>
<ul>
<li><code>favorite</code> 字段是一个多选类型，提供三个预设选项，默认选择了“Sleep”。</li>
<li><code>school</code> 字段也是一个多选类型，但其选项是由自定义的 <code>School</code> 结构体实例表示的，且支持默认选择。通过传入一个布尔值数组来指定哪些学校是默认被选中的，数组长度必须与提供的学校选项列表长度相同。</li>
</ul>
<p>在 <code>main</code> 函数中：</p>
<ul>
<li>首先初始化了 <code>User</code> 结构体的询问器实例，并分别为 <code>school</code> 和 <code>favorite</code> 字段指定了默认选择或直接使用默认选项。</li>
<li>当运行程序时，会按照顺序显示预设的提示信息，并根据设置的默认值进行交互式信息收集。</li>
<li>收集完成后，<code>.finish()</code> 方法返回一个包含了用户选择信息的 <code>User</code> 结构体实例，并将其输出至控制台。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced"><a class="header" href="#advanced">Advanced</a></h1>
<p>接下来，我们将探讨<code>dialogue_macro</code>库中的两个高级特性：<code>EnumAsker</code>和<code>Build</code>特质。</p>
<p><strong>EnumAsker 宏</strong>
<code>EnumAsker</code>正如其名，扩展了<code>Asker</code>功能以支持枚举类型的交互式输入。通过派生<code>EnumAsker</code>，可以轻松地为枚举类型定义一组选项，并在命令行中呈现给用户选择。这样，开发者无需手动处理枚举值的获取，而是在运行时自动根据用户的响应填充枚举字段。</p>
<p><code>EnumAsker</code>修饰的枚举自动实现<code>Build</code> trait。</p>
<p><strong>Build 特质</strong>
<code>Build</code>特质的设计目的是简化<code>Asker</code>接口的使用过程，特别是针对那些需要嵌套询问逻辑的情况。通过实现<code>Build</code>特质，子结构体或枚举能够拥有一个自包含的构建流程，只需调用<code>.build()</code>方法就能顺序执行所有的询问操作直至完成信息收集。这意味着不再需要分别调用每个字段对应的<code>asker()</code>方法以及最后的<code>finish()</code>方法来结束整个询问过程。对于具有嵌套结构的复杂用户输入场景，这一特质大大提升了代码的简洁性和可读性。所有作为子询问器使用的结构体都应该实现<code>Build</code>特质，以便于与顶层询问器进行整合。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumasker"><a class="header" href="#enumasker">EnumAsker</a></h1>
<p><code>EnumAsker</code> 是一个针对枚举类型的交互式询问功能宏，用于在命令行界面中提供用户选择。使用此宏时需要注意，被修饰的枚举变体不能是带有命名字段的结构体类型，而应该采用元组或者无数据变体的形式。</p>
<p><strong>不支持的枚举定义示例：</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(EnumAsker)]
enum Test {
    A {
        name: String,
    },
}
<span class="boring">}</span></code></pre></pre>
<p>上述代码中的 <code>Test</code> 枚举包含名为 <code>A</code> 的变体，该变体内含一个名为 <code>name</code> 的字符串字段。这种带命名字段的结构体风格并不符合 <code>EnumAsker</code> 的使用规范。</p>
<p><strong>支持的枚举定义形式：</strong></p>
<ol>
<li><strong>元组列表形式</strong>：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(EnumAsker)]
enum Test {
    A(Student, User),
    B(User),
}
<span class="boring">}</span></code></pre></pre>
<p>在这种情况下，<code>Test</code> 枚举的变体以元组形式出现，如 <code>A(Student, User)</code> 和 <code>B(User)</code>，这些变体可以包含其他结构体类型的组合，这完全满足 <code>EnumAsker</code> 的使用条件。</p>
<ol start="2">
<li><strong>空或无数据变体形式</strong>：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(EnumAsker)]
enum Test {
    A,
    B,
    C,
}
<span class="boring">}</span></code></pre></pre>
<p>同时，<code>EnumAsker</code> 也支持仅包含空或无数据变体（例如 <code>A</code>、<code>B</code> 和 <code>C</code>）的枚举定义。</p>
<h3 id="配置选项说明"><a class="header" href="#配置选项说明">配置选项说明</a></h3>
<p><code>EnumAsker</code> 提供了两种级别的配置项：枚举级别属性和变体级别属性。</p>
<p><strong>枚举级别属性</strong>：</p>
<ul>
<li><strong>prompt</strong>: 指定用户在进行选择时的提示信息文本。</li>
<li><strong>default</strong>: 设置默认选择项，其值应为枚举变体名称。</li>
<li><strong>theme</strong>: 设定对话框主题样式，具体主题将在后续部分详细说明。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, EnumAsker)]
#[asker(
    prompt = "选择注册类型",
    default = "Student",
    theme = "dialoguer::theme::ColorfulTheme"
)]
enum Register {
    ...
}
<span class="boring">}</span></code></pre></pre>
<p><strong>变体级别属性</strong>：</p>
<ul>
<li><strong>label</strong>: 用于配置各个选择项在命令行界面上显示的标签文本。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, EnumAsker)]
#[asker(...)]
enum Register {
    #[asker(label = "注册为普通用户")]
    User(User),
    #[asker(label = "注册为学生")]
    Student(Student),
    #[asker(label = "退出")]
    Exit,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>注意：</strong></p>
<p><code>EnumAsker</code>宏不会实现<code>asker()</code>方法，而是自动实现<code>Build</code> trait，通过调用<code>build()</code>方法即可收集用户输入。</p>
<h3 id="示例-5"><a class="header" href="#示例-5">示例</a></h3>
<h4 id="定义结构体与实现build-trait"><a class="header" href="#定义结构体与实现build-trait">定义结构体与实现<code>Build</code> trait</a></h4>
<p>首先定义了两个结构体：<code>User</code> 和 <code>Student</code>，分别用于存储普通用户和学生的信息。这两个结构体均派生了 <code>Asker</code> 和 <code>Clone</code> 特质，并实现了 <code>Build</code> trait：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Asker, Clone)]
struct User {
    #[input(with_default = true)]
    username: String,
    email: String,
}

impl Build for User {
    fn build() -&gt; Self {
        // 用户名提供默认值，邮件无默认值
        Self::asker()
            .username("Enter your username", "default_username".to_string())
            .email("Enter your email")
            .finish()
    }
}

#[derive(Debug, Asker, Clone)]
pub struct Student {
    username: String,
    student_id: String,
}

impl Build for Student {
    fn build() -&gt; Self {
        // 分别询问用户名和学生ID
        Self::asker()
            .username("Enter your username")
            .student_id("Enter your student ID")
            .finish()
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="利用enumasker处理枚举选项"><a class="header" href="#利用enumasker处理枚举选项">利用<code>EnumAsker</code>处理枚举选项</a></h4>
<p>接下来，我们定义了一个名为 <code>Register</code> 的枚举类型，它使用了 <code>EnumAsker</code> 宏：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, EnumAsker)]
#[asker(
    prompt = "Select registration type",
    default = "Student",
  	theme = "dialoguer::theme::ColorfulTheme"
)]
enum Register {
    // 普通用户注册选项
    #[asker(label = "Register as a regular user")]
    User(User),
    // 学生注册选项
    #[asker(label = "Register as a student")]
    Student(Student),
    // 退出程序的选项
    #[asker(label = "Exit")]
    Exit,
}
<span class="boring">}</span></code></pre></pre>
<p>在这个枚举中，每个变体都关联到一个结构体实例，并通过 <code>label</code> 参数指定了命令行界面中的显示文本。此外，我们还设置了 <code>prompt</code> 作为主提示信息、<code>default</code> 为默认选项。</p>
<h4 id="主函数逻辑"><a class="header" href="#主函数逻辑">主函数逻辑</a></h4>
<p>在 <code>main</code> 函数中，我们创建并获取用户的选择结果：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let choice = Register::build();
    
    match choice {
        Register::User(user) =&gt; println!("Registered regular user: {:?}", user),
        Register::Student(student) =&gt; println!("Registered student: {:?}", student),
        Register::Exit =&gt; println!("Exiting..."),
    }
}</code></pre></pre>
<p>当运行程序时，将按照以下流程执行：</p>
<ol>
<li>根据 <code>EnumAsker</code> 设置显示交互式菜单，用户可以选择注册类型（普通用户、学生或退出）。</li>
<li>根据用户的选项，调用相应结构体的 <code>build()</code> 方法收集用户信息。</li>
<li>根据匹配结果输出已注册的用户或学生信息，若选择退出则打印退出信息。</li>
</ol>
<p><img src="advanced/enum.assets/image-20240316153849647.png" alt="image-20240316153849647" /></p>
<p><img src="advanced/enum.assets/image-20240316153915455.png" alt="image-20240316153915455" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subasker"><a class="header" href="#subasker">SubAsker</a></h1>
<p><code>SubAsker</code> 是 <code>dialogue_macro</code> 库中用于标记结构体字段的属性，它允许将一个已实现 <code>Build</code> 特质的结构体或枚举类型嵌入到另一个结构体中，并作为一个子询问器进行交互式数据收集。</p>
<p>以下代码片段展示了如何在 <code>UserInput</code> 结构体中使用 <code>SubAsker</code> 属性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Asker)]
struct UserInput {
    // 其他用户输入字段...

    // 使用 SubAsker 标记字段以启用子询问器功能
    #[asker(SubAsker)]
    detailed_info: DetailedUserInfo,

    // 同样使用 SubAsker 对枚举类型进行嵌套询问
    #[asker(SubAsker)]
    choice: EnumSelection,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>重要提示：</strong></p>
<p>为了确保 <code>SubAsker</code> 正常工作，被该属性修饰的字段所对应的结构体或枚举类型必须实现 <code>Build</code> 这个特质。这样，在调用这些字段时，会自动触发其内部的 <code>.build()</code> 方法，从而逐层展开并执行相应的命令行交互逻辑。例如，在上面的示例中，<code>DetailedUserInfo</code> 和 <code>EnumSelection</code> 都需要实现 <code>Build</code> 特质。</p>
<h3 id="示例-6"><a class="header" href="#示例-6">示例</a></h3>
<p>在本示例中，我们将展示如何通过 <code>dialogue_macro</code> 库中的 <code>SubAsker</code> 属性以及相关的 <code>Asker</code> 和 <code>Build</code> 特质来实现结构化的、层次分明的命令行用户交互流程。</p>
<p>首先，我们定义了一个名为 <code>UserInput</code> 的结构体，并使用 <code>#[derive(Asker)]</code> 和 <code>#[asker(theme = "...")]</code> 宏对其进行装饰，以便于在命令行界面中进行信息收集。同时，结构体中包含两个字段：<code>detailed_info</code> 和 <code>choice</code>，它们都被标记为 <code>#[asker(SubAsker)]</code>，表示这两个字段将作为一个子询问器（SubAsker）来处理更深层次的用户输入。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dialogue_macro::{Asker, Build, EnumAsker};

#[derive(Debug, Asker)]
#[asker(theme = "dialogue_macro::ColorfulTheme")]
struct UserInput {
    username: String,
    is_student_status: bool,
    educational_institution: String,

    #[asker(SubAsker)]
    detailed_info: DetailedUserInfo,
    #[asker(SubAsker)]
    choice: EnumSelection,
}
<span class="boring">}</span></code></pre></pre>
<p>接下来，我们定义了两个用于嵌套询问的类型：</p>
<ol>
<li><strong>DetailedUserInfo</strong> 结构体，其中包含了用户的电子邮件地址和年龄信息。这个结构体实现了 <code>Debug</code>、<code>Clone</code> 和 <code>Asker</code> 特质，并且为了配合 <code>SubAsker</code> 使用，还额外实现了 <code>Build</code> 特质。在 <code>impl Build for DetailedUserInfo</code> 中，我们定义了 <code>.build()</code> 方法以顺序获取用户邮箱地址和年龄。</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Asker)]
struct DetailedUserInfo {
    email_address: String,
    age: u8,
}

impl Build for DetailedUserInfo {
    fn build() -&gt; Self {
        Self::asker()
            .email_address("请提供您的邮箱地址")
            .age("请输入您的年龄")
            .finish()
    }
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>EnumSelection</strong> 枚举，它包含了三个选项（OptionD、OptionE、OptionF）。此枚举不仅实现了 <code>Debug</code> 和 <code>Clone</code> 特质，同时也派生了 <code>EnumAsker</code> 特质，这意味着它可以作为子询问器呈现给用户选择。</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, EnumAsker, Clone)]
enum EnumSelection {
    OptionD,
    OptionE,
    OptionF,
}
<span class="boring">}</span></code></pre></pre>
<p>最后，在主函数中，我们实例化了 <code>UserInput</code> 并依次调用各个字段对应的询问方法：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let collected_user_input = UserInput::asker()
        .username("请输入用户名")
        .is_student_status("您是否是学生身份?")
        .educational_institution("请输入您的学校名称")
        // 调用 SubAsker 来收集详细的用户信息
        .detailed_info()
        // 调用另一个 SubAsker 来让用户从枚举选项中做出选择
        .choice()
        // 收集所有用户输入并结束询问过程
        .finish();

    println!("{:?}", collected_user_input);
}</code></pre></pre>
<p>通过这种方式，当运行程序时，用户将会按照结构化的层级顺序依次输入相关信息，从而实现复杂而有序的命令行交互体验。</p>
<p><img src="advanced/subasker.assets/image-20240316161316179.png" alt="image-20240316161316179" /></p>
<p><img src="advanced/subasker.assets/image-20240316161356463.png" alt="image-20240316161356463" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theme"><a class="header" href="#theme">Theme</a></h1>
<p>在使用 <code>dialogue_macro</code> 库中的 <code>Asker</code> 和 <code>EnumAsker</code> 特性修饰结构体或枚举时，可以通过在派生宏中指定 <code>theme</code> 参数来自定义用户交互界面的主题风格。主题需要实现 <code>dialoguer::theme::Theme</code> 和 <code>Default</code> 两个特质。</p>
<p><strong>注意：</strong>
如果不特别指定 <code>theme</code> 参数，则默认采用 <code>dialogue_macro::ColorfulTheme</code> 这一彩色主题。</p>
<h3 id="示例-7"><a class="header" href="#示例-7">示例</a></h3>
<p>下面的示例展示了如何使用 <code>dialoguer</code> 库提供的 <code>ColorfulTheme</code> 彩色主题：</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
use dialogue_macro::Asker;

#[derive(Asker, Debug)]
// 指定主题色
#[asker(theme = "dialoguer::theme::ColorfulTheme")]
struct User {
    #[multiselect(prompt = "Please select your favorite", options = ["Eat", "Sleep", "Code"], default = [1])]
    favorite: Vec&lt;String&gt;,

    #[multiselect(
        prompt = "Please select your school: ",
        with_default = true,
        options = [
            School { name: "Tsinghua University".to_string() },
            School { name: "Peking University".to_string() },
            School { name: "Henan Polytechnic University".to_string() }
        ]
    )]
    school: Vec&lt;School&gt;,
}

#[derive(Debug, Clone)]
struct School {
    name: String,
}

impl ToString for School {
    fn to_string(&amp;self) -&gt; String {
        self.name.clone()
    }
}

fn main() {
    let user = User::asker()
        .school(&amp;[true, false, true])
        .favorite()
        .finish();

    println!("{:?}", user);
}
</code></pre></pre>
<p><img src="advanced/theme.assets/image-20240316162358388.png" alt="image-20240316162358388" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <script src="https://cdn.staticfile.net/translate.js/3.1.2/translate.js"></script>
        <!-- Custom JS scripts -->
        <script src="theme/custom/main.js"></script>
        
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
